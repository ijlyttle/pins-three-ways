[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pins: Three Ways",
    "section": "",
    "text": "The purpose of this book is to make a brief demonstration of the pins package using R and Python, and to imagine how it might be used with JavaScript.\nPins helps you manage sharing data with yourself, others, or even CI processes. There are two levels of abstraction:\n\npin: a “thing” to be shared as a file. It could be a data frame, a model, a nested list (dictionary, object). If it can be serialized to a file, it can be pinned. Some serializations, such as CSV, JSON, and arrow, are common to multiple languages (R, Python, JavaScript), so can be used for cross-language collaboration. Other serializations are specific to a language (pickle for Python, rds for R).\nboard: a collection of pins hosted at a “place”. A board could be hosted at Azure Blob Storage, an Amazon S3 Bucket, RStudio (soon to be Posit) Connect, a local filesystem, a remote URL, …\n\nPins distinguishes itself from straightforward filesharing by:\n\nstoring metadata, including user-defined metadata.\nthis metadata allows pins to handle deserialization automatically.\nsupporting versioning.\nsupporting authentication for boards (e.g. AWS S3).\ncaching results locally, so that reading a pin may not require a download.\n\n\n\nIn the rest of the book I (plan to):\n\nuse R to:\n\ncreate a board.\nwrite a data frame as a pin, using the arrow format.\nread the pin into a data frame.\n\nuse Python to:\n\nread the data-frame pin written using R.\nwrite a pandas data-frame as a pin using the arrow format.\n\nuse JavaScript to:\n\nread the data-frame pins written using R and Python, using arquero, which supports the arrow format.\n\n\n\n\n\n\n\n\nQuarto implementation\n\n\n\n\n\nEvery time a pin is written, a new file is created on the board; this supports versioning. I don’t want to write a new version of the same file each time this book is rendered (especially on CI).\nTo avoid this, for code-blocks where I write pins:\n\nI include code that I run only manually.\nI paste the response into the prose manually.\n\n\n\n\nThis book is rendered using the quarto actions, but not on pull requests.\n\n\n\nI have some ideas for the conclusions I might come to in the course of writing the rest of this material. That said, I’ll want to make some actual observations before calling for any action. I’ll update this section as I go."
  },
  {
    "objectID": "using-r.html",
    "href": "using-r.html",
    "title": "1  Using R",
    "section": "",
    "text": "The first implementation of the pins package was made in R. In this chapter, I will:"
  },
  {
    "objectID": "using-r.html#folder-board",
    "href": "using-r.html#folder-board",
    "title": "1  Using R",
    "section": "1.1 Folder board",
    "text": "1.1 Folder board\nThe first step is to create a board:\n\nboard_here <- board_folder(here(\"pins\"), versioned = TRUE)\n\n\n1.1.1 Writing pins\nThe next step is to write a pin. Let’s write the penguins data-frame as a JSON pin:\n\npin_write(\n  board_here, \n  x = penguins, \n  name = \"penguins-json\", \n  type = \"json\",\n  metadata = list(\n    authors = c(\"Allison Horst\", \"Alison Hill\", \"Kristen Gorman\"),\n    license = \"CCO\",\n    url = \"https://allisonhorst.github.io/palmerpenguins/\"\n  ),\n  versioned = TRUE\n)\n\nCreating new version '20220805T171936Z-fa33e'\nWriting to pin 'penguins-json'\nAnd as a CSV file:\n\npin_write(\n  board_here, \n  x = penguins, \n  name = \"penguins-csv\", \n  type = \"csv\",\n  metadata = list(\n    authors = c(\"Allison Horst\", \"Alison Hill\", \"Kristen Gorman\"),\n    license = \"CCO\",\n    url = \"https://allisonhorst.github.io/palmerpenguins/\"\n  ),\n  versioned = TRUE\n)\n\nCreating new version '20220811T170157Z-809e9'\nWriting to pin 'penguins-csv'\nAs you can see, the version number is a combination of the creation time (UTC) and a (shortened) hash of the contents.\nI also want to create an arrow version of the pin.\nThe pin_write() function offers type = \"arrow\", which uses arrow::write_feather(). However, the default behavior is to use compression; pins does not offer (so far as I know) a way to supply the compression argument to arrow::write_feather(). This presents a problem for me because the arrow implementation for JavaScript does not support compression.\nIt should not surprise you that pins offers an escape hatch, I can wrap pins_upload() in a function:\n\npin_write_arrow_uncompressed <- function(board, x, name = NULL, ...) {\n  \n  tempfile <- withr::local_tempfile()\n  \n  arrow::write_feather(x, tempfile, compression = \"uncompressed\")\n  \n  result <- pins::pin_upload(\n    board,\n    paths = tempfile,\n    name = name,\n    ...\n  )\n  \n  message(glue::glue(\"Writing to pin '{name}'\"))\n  \n  invisible(result)\n}\n\n\npin_write_arrow_uncompressed(\n  board_here, \n  x = penguins, \n  name = \"penguins-arrow\", \n  metadata = list(\n    authors = c(\"Allison Horst\", \"Alison Hill\", \"Kristen Gorman\"),\n    license = \"CCO\",\n    url = \"https://allisonhorst.github.io/palmerpenguins/\"\n  )\n)\n\nCreating new version '20220811T170224Z-ef034'\nWriting to pin 'penguins-arrow'\n\n\n1.1.2 Reading pins\n\npenguins_json <- pin_read(board_here, name = \"penguins-json\")\ncompare(penguins, penguins_json)\n\n`class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n`class(new)`:                \"data.frame\"\n\n`old$species` is an S3 object of class <factor>, an integer vector\n`new$species` is a character vector ('Adelie', 'Adelie', 'Adelie', 'Adelie', 'Adelie', ...)\n\n`old$island` is an S3 object of class <factor>, an integer vector\n`new$island` is a character vector ('Torgersen', 'Torgersen', 'Torgersen', 'Torgersen', 'Torgersen', ...)\n\n`old$sex` is an S3 object of class <factor>, an integer vector\n`new$sex` is a character vector ('male', 'female', 'female', NA, 'female', ...)\n\n\nWe see some differences between the original (“old”) version and “new” version of penguins:\n\nnew version does not have the “tibble” classes.\nnew version does not know that some of the colunms are factors.\n\nThese are not huge differences; in fact, the JSON format has no way of encoding that something is a factor.\nLet’s look at the arrow version. Because we used a file format (using pin_upload()), we need also to write a handler for pin_download():\n\npin_read_arrow_uncompressed <- function(board, name, ...) {\n  \n  tempfile <- pins::pin_download(board, name, ...)\n  \n  arrow::read_feather(tempfile)\n}\n\n\npenguins_arrow <- pin_read_arrow_uncompressed(board_here, \"penguins-arrow\")\ncompare(penguins, penguins_arrow)\n\n✔ No differences\n\n\nThe fact that there are no differences is one of the many cool things about arrow.\n\n\n1.1.3 Timeseries\nOne thing I am interested in is how to manage data frames that contain dates or datetimes. Concretely, in R, POSIXct and Date; I know there are other flavors of time, but for me, these are the big two.\n\nindex <- seq(0, 10)\n\ntime <- \n  tibble(\n    date = ymd(\"2010-01-01\") + index, # one per day\n    datetime = \n      ymd_hms(\"2020-09-01 00:00:00\", tz = \"America/Denver\") + index, # per second\n    value = index\n  ) %>%\n  print()\n\n# A tibble: 11 × 3\n   date       datetime            value\n   <date>     <dttm>              <int>\n 1 2010-01-01 2020-09-01 00:00:00     0\n 2 2010-01-02 2020-09-01 00:00:01     1\n 3 2010-01-03 2020-09-01 00:00:02     2\n 4 2010-01-04 2020-09-01 00:00:03     3\n 5 2010-01-05 2020-09-01 00:00:04     4\n 6 2010-01-06 2020-09-01 00:00:05     5\n 7 2010-01-07 2020-09-01 00:00:06     6\n 8 2010-01-08 2020-09-01 00:00:07     7\n 9 2010-01-09 2020-09-01 00:00:08     8\n10 2010-01-10 2020-09-01 00:00:09     9\n11 2010-01-11 2020-09-01 00:00:10    10\n\ntz(time$datetime)\n\n[1] \"America/Denver\"\n\n\nLet’s write this out for csv, json, and arrow:\n\npin_write(board_here, x = time, name = \"time-csv\", type = \"csv\")\npin_write(board_here, x = time, name = \"time-json\", type = \"json\")\npin_write_arrow_uncompressed(board_here, x = time, name = \"time-arrow\")\n\nCreating new version '20220811T224202Z-06d53'\nWriting to pin 'time-csv'\n\nCreating new version '20220811T224202Z-70d59'\nWriting to pin 'time-json'\n\nCreating new version '20220811T224202Z-b1900'\nWriting to pin 'time-arrow'\n\ntime_csv <- pin_read(board_here, \"time-csv\") %>% print()\n\n         date            datetime value\n1  2010-01-01 2020-09-01 00:00:00     0\n2  2010-01-02 2020-09-01 00:00:01     1\n3  2010-01-03 2020-09-01 00:00:02     2\n4  2010-01-04 2020-09-01 00:00:03     3\n5  2010-01-05 2020-09-01 00:00:04     4\n6  2010-01-06 2020-09-01 00:00:05     5\n7  2010-01-07 2020-09-01 00:00:06     6\n8  2010-01-08 2020-09-01 00:00:07     7\n9  2010-01-09 2020-09-01 00:00:08     8\n10 2010-01-10 2020-09-01 00:00:09     9\n11 2010-01-11 2020-09-01 00:00:10    10\n\ncompare(time, time_csv)\n\n`class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n`class(new)`:                \"data.frame\"\n\n`old$date` is an S3 object of class <Date>, a double vector\n`new$date` is an S3 object of class <factor>, an integer vector\n\n`old$datetime` is an S3 object of class <POSIXct/POSIXt>, a double vector\n`new$datetime` is an S3 object of class <factor>, an integer vector\n\n\nThe reading function seems to use stringsAsFactors = TRUE, and the seriailizing function is writes out to local time. The time-zone is not taken into account, but that’s hard to automate.\n\ntime_json <- pin_read(board_here, \"time-json\") %>% print()\n\n         date            datetime value\n1  2010-01-01 2020-09-01 00:00:00     0\n2  2010-01-02 2020-09-01 00:00:01     1\n3  2010-01-03 2020-09-01 00:00:02     2\n4  2010-01-04 2020-09-01 00:00:03     3\n5  2010-01-05 2020-09-01 00:00:04     4\n6  2010-01-06 2020-09-01 00:00:05     5\n7  2010-01-07 2020-09-01 00:00:06     6\n8  2010-01-08 2020-09-01 00:00:07     7\n9  2010-01-09 2020-09-01 00:00:08     8\n10 2010-01-10 2020-09-01 00:00:09     9\n11 2010-01-11 2020-09-01 00:00:10    10\n\ncompare(time, time_json)\n\n`class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n`class(new)`:                \"data.frame\"\n\n`old$date` is an S3 object of class <Date>, a double vector\n`new$date` is a character vector ('2010-01-01', '2010-01-02', '2010-01-03', '2010-01-04', '2010-01-05', ...)\n\n`old$datetime` is an S3 object of class <POSIXct/POSIXt>, a double vector\n`new$datetime` is a character vector ('2020-09-01 00:00:00', '2020-09-01 00:00:01', '2020-09-01 00:00:02', '2020-09-01 00:00:03', '2020-09-01 00:00:04', ...)\n\n\nFor the JSON pin, we get strings, but we see that the time had been serialized as a local time. It would be more-robust to serialize as ISO-8601, then somehow store the timezone as metadata. That said, it would be difficult to imagine how to do that.\n\ncompare(time, pin_read_arrow_uncompressed(board_here, \"time-arrow\"))\n\n✔ No differences\n\n\nAgain, Arrow is working as advertised.\n\n\n1.1.4 Deploying pins\nTo make it easier to deploy a board on GitHub (or any other web server), I am using the experimental pinsManifest package to create a manifest of pins. This file, pins.txt is written to the board’s root directory; it will make it easier to create a board_url() to read pins.\n\npin_write_manifest(board_here)"
  },
  {
    "objectID": "using-r.html#remote-board",
    "href": "using-r.html#remote-board",
    "title": "1  Using R",
    "section": "1.2 Remote board",
    "text": "1.2 Remote board\nWith this board now availble using GitHub Pages, we can use board_url(), which can be useful for sharing data publicly, i.e. without requiring authentication.\nNote that we use the board_url_manifest() in the experimental pinsManifest package to build the board. This uses the manifest file, pins.txt, to compile the information needed to build a pins::board_url().\n\nboard_remote <- \n  board_url_manifest(\"https://ijlyttle.github.io/pins-three-ways/pins/\")\n\n\n1.2.1 Reading pins\nIt should not surprise us that the remote versions of the pins are the identical to the local versions.\n\npenguins_json_remote <- pin_read(board_remote, name = \"penguins-json\")\ncompare(penguins_json, penguins_json_remote)\n\n✔ No differences\n\n\n\npenguins_arrow_remote <- \n  pin_read_arrow_uncompressed(board_remote, name = \"penguins-arrow\")\ncompare(penguins_arrow, penguins_arrow_remote)\n\n✔ No differences"
  },
  {
    "objectID": "using-python.html",
    "href": "using-python.html",
    "title": "2  Using Python",
    "section": "",
    "text": "For this chapter, I will use Python via R’s reticulate package. All code blocks that do not use Python will have a comment at the top, just like this one which uses R:"
  },
  {
    "objectID": "using-python.html#folder-board",
    "href": "using-python.html#folder-board",
    "title": "2  Using Python",
    "section": "2.1 Folder board",
    "text": "2.1 Folder board\n\nboard_here = board_folder(\"pins\")\nboard_here.pin_list()\n\n['time-json', 'penguins-json', 'time-arrow', 'penguins-arrow', 'pins.txt', 'time-csv', 'penguins-csv']\n\n\nShould this be listing a test file?\n\n2.1.1 Read\n\npenguins_csv = board_here.pin_read(\"penguins-csv\")\n\n\npenguins_csv\n\n       species     island  bill_length_mm  ...  body_mass_g     sex  year\n0       Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1       Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2       Adelie  Torgersen            40.3  ...       3250.0  female  2007\n3       Adelie  Torgersen             NaN  ...          NaN     NaN  2007\n4       Adelie  Torgersen            36.7  ...       3450.0  female  2007\n..         ...        ...             ...  ...          ...     ...   ...\n339  Chinstrap      Dream            55.8  ...       4000.0    male  2009\n340  Chinstrap      Dream            43.5  ...       3400.0  female  2009\n341  Chinstrap      Dream            49.6  ...       3775.0    male  2009\n342  Chinstrap      Dream            50.8  ...       4100.0    male  2009\n343  Chinstrap      Dream            50.2  ...       3775.0  female  2009\n\n[344 rows x 8 columns]\n\n\n\n\n2.1.2 Timeseries\n\ntime_csv = board_here.pin_read(\"time-csv\")\ntime_csv\n\n          date             datetime  value\n0   2010-01-01  2020-09-01 00:00:00      0\n1   2010-01-02  2020-09-01 00:00:01      1\n2   2010-01-03  2020-09-01 00:00:02      2\n3   2010-01-04  2020-09-01 00:00:03      3\n4   2010-01-05  2020-09-01 00:00:04      4\n5   2010-01-06  2020-09-01 00:00:05      5\n6   2010-01-07  2020-09-01 00:00:06      6\n7   2010-01-08  2020-09-01 00:00:07      7\n8   2010-01-09  2020-09-01 00:00:08      8\n9   2010-01-10  2020-09-01 00:00:09      9\n10  2010-01-11  2020-09-01 00:00:10     10\n\ntime_csv.dtypes\n\ndate        object\ndatetime    object\nvalue        int64\ndtype: object\n\n\nWe are not parsing dates or datetimes. We don’t have the timezone.\nThere’s no driver yet for JSON, so let’s try Arrow:\n\n# this seems hacky, but I'm sure it will get sorted out\ntime_arrow = pd.read_feather(board_here.pin_read(\"time-arrow\")[0])\n\n\ntime_arrow\n\n          date                  datetime  value\n0   2010-01-01 2020-09-01 00:00:00-06:00      0\n1   2010-01-02 2020-09-01 00:00:01-06:00      1\n2   2010-01-03 2020-09-01 00:00:02-06:00      2\n3   2010-01-04 2020-09-01 00:00:03-06:00      3\n4   2010-01-05 2020-09-01 00:00:04-06:00      4\n5   2010-01-06 2020-09-01 00:00:05-06:00      5\n6   2010-01-07 2020-09-01 00:00:06-06:00      6\n7   2010-01-08 2020-09-01 00:00:07-06:00      7\n8   2010-01-09 2020-09-01 00:00:08-06:00      8\n9   2010-01-10 2020-09-01 00:00:09-06:00      9\n10  2010-01-11 2020-09-01 00:00:10-06:00     10\n\n\n\ntime_arrow.dtypes\n\ndate                                object\ndatetime    datetime64[ns, America/Denver]\nvalue                                int32\ndtype: object\n\n\n\ntime_arrow['date'].values\n\narray([datetime.date(2010, 1, 1), datetime.date(2010, 1, 2),\n       datetime.date(2010, 1, 3), datetime.date(2010, 1, 4),\n       datetime.date(2010, 1, 5), datetime.date(2010, 1, 6),\n       datetime.date(2010, 1, 7), datetime.date(2010, 1, 8),\n       datetime.date(2010, 1, 9), datetime.date(2010, 1, 10),\n       datetime.date(2010, 1, 11)], dtype=object)"
  },
  {
    "objectID": "using-python.html#remote-board",
    "href": "using-python.html#remote-board",
    "title": "2  Using Python",
    "section": "2.2 Remote board",
    "text": "2.2 Remote board\nI don’t think I will create a Python package; maybe I can just put together a quick script to convert a pins manafest into a dictionary.\n\nimport requests\nimport yaml\n\n# read file, parse into manifest\nurl_root = \"https://ijlyttle.github.io/pins-three-ways/pins\"\nreq = requests.get(f\"{url_root}/pins.txt\")\nmanifest = yaml.safe_load(req.text)\n\n\n# use the most-recent version\npin_paths = {}\nfor key, value in manifest.items():\n    pin_paths[key] = max(value)\n \npin_paths   \n\n{'penguins-arrow': 'penguins-arrow/20220811T170224Z-ef034/', 'penguins-csv': 'penguins-csv/20220811T170157Z-809e9/', 'penguins-json': 'penguins-json/20220811T170152Z-fa33e/', 'time-arrow': 'time-arrow/20220811T224202Z-b1900/', 'time-csv': 'time-csv/20220811T224202Z-06d53/', 'time-json': 'time-json/20220811T224202Z-70d59/'}\n\n\nThe Python version has a board constructor board_urls():\n\nboard_remote = board_urls(url_root, pin_paths)\nboard_remote.pin_list()\n\n['penguins-arrow', 'penguins-csv', 'penguins-json', 'time-arrow', 'time-csv', 'time-json']\n\n\n\n2.2.1 Read\nWe can read the CSV pin:\n\nboard_remote.pin_read(\"penguins-csv\")\n\n       species     island  bill_length_mm  ...  body_mass_g     sex  year\n0       Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1       Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2       Adelie  Torgersen            40.3  ...       3250.0  female  2007\n3       Adelie  Torgersen             NaN  ...          NaN     NaN  2007\n4       Adelie  Torgersen            36.7  ...       3450.0  female  2007\n..         ...        ...             ...  ...          ...     ...   ...\n339  Chinstrap      Dream            55.8  ...       4000.0    male  2009\n340  Chinstrap      Dream            43.5  ...       3400.0  female  2009\n341  Chinstrap      Dream            49.6  ...       3775.0    male  2009\n342  Chinstrap      Dream            50.8  ...       4100.0    male  2009\n343  Chinstrap      Dream            50.2  ...       3775.0  female  2009\n\n[344 rows x 8 columns]\n\n\n\npenguins_arrow = pd.read_feather(board_here.pin_read(\"penguins-arrow\")[0])\npenguins_arrow\n\n       species     island  bill_length_mm  ...  body_mass_g     sex  year\n0       Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1       Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2       Adelie  Torgersen            40.3  ...       3250.0  female  2007\n3       Adelie  Torgersen             NaN  ...          NaN     NaN  2007\n4       Adelie  Torgersen            36.7  ...       3450.0  female  2007\n..         ...        ...             ...  ...          ...     ...   ...\n339  Chinstrap      Dream            55.8  ...       4000.0    male  2009\n340  Chinstrap      Dream            43.5  ...       3400.0  female  2009\n341  Chinstrap      Dream            49.6  ...       3775.0    male  2009\n342  Chinstrap      Dream            50.8  ...       4100.0    male  2009\n343  Chinstrap      Dream            50.2  ...       3775.0  female  2009\n\n[344 rows x 8 columns]\n\npenguins_arrow.dtypes\n\nspecies              category\nisland               category\nbill_length_mm        float64\nbill_depth_mm         float64\nflipper_length_mm     float64\nbody_mass_g           float64\nsex                  category\nyear                    int32\ndtype: object\n\npenguins_arrow['species'].values\n\n['Adelie', 'Adelie', 'Adelie', 'Adelie', 'Adelie', ..., 'Chinstrap', 'Chinstrap', 'Chinstrap', 'Chinstrap', 'Chinstrap']\nLength: 344\nCategories (3, object): ['Adelie', 'Chinstrap', 'Gentoo']"
  },
  {
    "objectID": "using-javascript.html",
    "href": "using-javascript.html",
    "title": "3  Using JavaScript",
    "section": "",
    "text": "Here’s a link to an Observable notebook; it will have to do for now."
  }
]